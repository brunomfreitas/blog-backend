name: Build, Test and Push Blog App

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/blog-app
      APP_PORT: 3000
      DB_PORT: 5432
      DB_NAME: blog
      DB_USER: blog_user
      DB_PASS: blog_user
      NET_NAME: blog-network

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Gera metadados de tags (latest na main + sha)
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha

      # ---------- Build para teste (carrega localmente na runner) ----------
      - name: Build (load for smoke test)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          load: true                # imagem local: $IMAGE_NAME:ci
          push: false
          tags: ${{ env.IMAGE_NAME }}:ci
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production

      # ---------- Smoke test com rede + Postgres + App ----------
      - name: Smoke test (network + postgres + app)
        run: |
          set -e
          docker network create --driver bridge $NET_NAME
          docker volume create blog-pgdata

          docker run -d --name blog_postgres \
            --network $NET_NAME \
            -e POSTGRES_USER="${DB_USER}" \
            -e POSTGRES_PASSWORD="${DB_PASS}" \
            -e POSTGRES_DB="${DB_NAME}" \
            -v blog-pgdata:/var/lib/postgresql/data \
            -p 5433:5432 \
            --health-cmd="pg_isready -U ${DB_USER} -d ${DB_NAME}" \
            --health-interval=5s \
            --health-timeout=3s \
            --health-retries=20 \
            postgres:16-alpine

          echo "Aguardando Postgres ficar healthy..."
          for i in {1..60}; do
            status=$(docker inspect --format='{{json .State.Health.Status}}' blog_postgres | tr -d '"')
            if [ "$status" = "healthy" ]; then
              echo "Postgres OK."
              break
            fi
            sleep 2
          done
          test "$status" = "healthy"

          docker run -d --name blog-app-test \
            --network $NET_NAME \
            -p ${APP_PORT}:3000 \
            -e DATABASE_HOST="blog_postgres" \
            -e DATABASE_NAME="${DB_NAME}" \
            -e DATABASE_USER="${DB_USER}" \
            -e DATABASE_PASSWORD="${DB_PASS}" \
            -e DATABASE_PORT="${DB_PORT}" \
            -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            -e JWT_EXPIRES_IN="1d" \
            -e NODE_ENV="production" \
            ${{ env.IMAGE_NAME }}:ci

          echo "Aguardando app subir..."
          sleep 15

          echo "Logs do app:"
          docker logs --tail=200 blog-app-test || true

          # Se vocÃª tiver endpoint de health:
          # curl -fsS http://localhost:${APP_PORT}/healthz

          # Confirma container rodando
          docker ps --filter "name=blog-app-test"

      - name: Cleanup smoke test
        if: always()
        run: |
          docker rm -f blog-app-test || true
          docker rm -f blog_postgres || true
          docker network rm $NET_NAME || true
          docker volume rm blog-pgdata || true

      # ---------- Build final + PUSH (usa tags do metadata-action) ----------
      - name: Build and Push (final)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
